for (k in Krange) {
p <- c(r = 0.5, K=k)
s <- c(x = 0.01)
out <- ode(func=model, y=s, times=times, parms=p)
lines(times, out[,2])
}
#k <- 1
for (k in Krange) {
p <- c(r = 0.5, K=k)
s <- c(x = 0.01)
out <- ode(func=model, y=s, times=times, parms=p)
plot(times, out[,2])
}
plot.new()
#k <- 1
for (k in Krange) {
p <- c(r = 0.5, K=k)
s <- c(x = 0.01)
out <- ode(func=model, y=s, times=times, parms=p)
lines(times, out[,2])
}
plot.new()
plot.window(xlim = c(0, tend), ylim = c(0, max(xrange)))
times
plot.new()
plot.window(xlim = c(0, max(times)), ylim = c(0, max(Krange)))
box()
title(main = "Logistic equation", xlab = "t", ylab = "N(t)")
axis(1)
axis(2)
plot.new()
plot.window(xlim = c(0, max(times)), ylim = c(0, max(Krange)))
box()
title(main = "Logistic equation", xlab = "t", ylab = "N(t)")
axis(1)
axis(2)
#k <- 1
for (k in Krange) {
p <- c(r = 0.5, K=k)
s <- c(x = 0.01)
out <- ode(func=model, y=s, times=times, parms=p)
lines(times, out[,2])
}
plot.new()
plot.window()
plot.new()
#plot.window(xlim = c(0, max(times)), ylim = c(0, max(Krange)))
box()
title(main = "Logistic equation", xlab = "t", ylab = "N(t)")
axis(1)
axis(2)
#k <- 1
for (k in Krange) {
p <- c(r = 0.5, K=k)
s <- c(x = 0.01)
out <- ode(func=model, y=s, times=times, parms=p)
lines(times, out[,2])
}
plot.new()
plot.window(xlim = c(0, max(times)), ylim = c(0, max(Krange)))
box()
title(main = "Logistic equation", xlab = "t", ylab = "N(t)")
axis(1)
axis(2)
#k <- 1
for (k in Krange) {
p <- c(r = 0.5, K=k)
s <- c(x = 0.01)
out <- ode(func=model, y=s, times=times, parms=p)
lines(times, out[,2])
}
####################################################################################
Rrange <- c(0.5,1,1.5)
####################################################################################
Rrange <- c(0.5,1,1.5)
plot.new()
plot.window(xlim = c(0, max(times)), ylim = c(0, max(Krange)))
box()
title(main = "Logistic equation", xlab = "t", ylab = "N(t)")
axis(1)
axis(2)
#k <- 1
for (r in Rrange) {
p <- c(r = r, K = 10)
s <- c(x = 0.01)
out <- ode(func=model, y=s, times=times, parms=p)
lines(times, out[,2])
}
####################################################################################
### Allee effect
model <- function(t, s, p) {
with(as.list(c(s,p)), {
dx <- r*x*(x/A - 1)*(1 - x/K)
return(list(c(dx)))
})
}
K = 10
A = 5
r = 0.5
s = c(x = 0.01)
times <- seq(from = 0, to = 100, by = 0.1)
p <- c(r, K)
p
p <- c(r=r, K=R)
p <- c(r=r, K=K)
p
out <- ode(func = model, y = s, times = times, parms = p)
plot(times, out[,2])
#k <- 1
Srange <- c(1,2,3,4,5,6,7,8,9)
plot.new()
plot.window(xlim = c(0, max(times)), ylim = c(0, max(Krange)))
box()
title(main = "Allee effect", xlab = "t", ylab = "N(t)")
axis(1)
axis(2)
#k <- 1
Srange <- c(1,2,3,4,5,6,7,8,9)
for (i in Srange) {
p <- c(r = r, K = 10)
s <- c(x = i)
out <- ode(func=model, y=s, times=times, parms=p)
lines(times, out[,2])
}
plot.new()
plot.window(xlim = c(0, max(times)), ylim = c(0, K))
box()
title(main = "Allee effect", xlab = "t", ylab = "N(t)")
axis(1)
axis(2)
#k <- 1
Srange <- c(1,2,3,4,5,6,7,8,9)
for (i in Srange) {
p <- c(r = r, K = 10)
s <- c(x = i)
out <- ode(func=model, y=s, times=times, parms=p)
lines(times, out[,2])
}
####################################################################################
### Predator-Prey
model <- function(t, s, p) {
with(as.list(c(s,p)), {
dP <- s*xP*(1 - (h*P)/xN)
dN <- r*xN*(1 - xN/K) - ((k*xN)/(D+xN))*P
return(list(c(dP,dN)))
})
}
s = 0.5
r = 1
h = 10
K = 10
k = 10
D = 1
s = c(xN0 = 6, xP0 = 0.6)
times <- seq(from = 0, to = 100, by = 0.1)
p <- c(s=s, r=r, h=h, K=K, k=k, D=D)
p
s = c(xN0 = 6, xP0 = 0.6)
s
s = 0.5
r = 1
h = 10
K = 10
k = 10
D = 1
s = c(xN0 = 6, xP0 = 0.6)
s = 0.5
r = 1
h = 10
K = 10
k = 10
D = 1
scond = c(xN0 = 6, xP0 = 0.6)
times <- seq(from = 0, to = 100, by = 0.1)
p <- c(s=s, r=r, h=h, K=K, k=k, D=D)
p
s = 0.5
r = 1
h = 10
K = 10
k = 10
D = 1
scond = c(xN0 = 6, xP0 = 0.6)
times <- seq(from = 0, to = 100, by = 0.1)
p <- c(s=s, r=r, h=h, K=K, k=k, D=D)
out <- ode(func = model, y = scond, times = times, parms = p)
scond = c(xN = 6, xP = 0.6)
times <- seq(from = 0, to = 100, by = 0.1)
p <- c(s=s, r=r, h=h, K=K, k=k, D=D)
out <- ode(func = model, y = scond, times = times, parms = p)
####################################################################################
### Predator-Prey
model <- function(t, s, p) {
with(as.list(c(s,p)), {
dP <- s*xP*(1 - (h*xP)/xN)
dN <- r*xN*(1 - xN/K) - ((k*xN)/(D+xN))*xP
return(list(c(dP,dN)))
})
}
s = 0.5
r = 1
h = 10
K = 10
k = 10
D = 1
scond = c(xN = 6, xP = 0.6)
times <- seq(from = 0, to = 100, by = 0.1)
p <- c(s=s, r=r, h=h, K=K, k=k, D=D)
out <- ode(func = model, y = scond, times = times, parms = p)
plot(times, out[,2])
out
plot(times, out[,2]])
plot(times, out[,2])
plot(times, out[,3])
plot(times, out[,2])
plot(times, out[,3])
c(out[,2],out[,3])
max(c(out[,2],out[,3]))
plot.new()
plot.window(xlim = c(0, max(times)), ylim = c(0, max(c(out[,2],out[,3]))))
box()
axis(1)
axis(2)
lines(times, out[,2])
lines(times, out[,3])
s = 0.1
r = 1
h = 10
K = 10
k = 10
D = 1
scond = c(xN = 6, xP = 0.6)
times <- seq(from = 0, to = 100, by = 0.1)
p <- c(s=s, r=r, h=h, K=K, k=k, D=D)
out <- ode(func = model, y = scond, times = times, parms = p)
plot(times, out[,2])
plot(times, out[,3])
plot.new()
plot.new()
plot.window(xlim = c(0, max(times)), ylim = c(0, max(c(out[,2],out[,3]))))
box()
axis(1)
axis(2)
lines(times, out[,2])
lines(times, out[,3])
s = 2
r = 1
h = 10
K = 10
k = 10
D = 1
scond = c(xN = 6, xP = 0.6)
times <- seq(from = 0, to = 100, by = 0.1)
p <- c(s=s, r=r, h=h, K=K, k=k, D=D)
out <- ode(func = model, y = scond, times = times, parms = p)
plot(times, out[,2])
plot(times, out[,3])
plot(out[,2],out[,3])
r
# ## Load the necessary libraries
library ( packcircles )
library ( ggplot2 )
library ( Hmisc )
library ( EnvStats )
library ( plyr )
library ( reshape2 )
library ( cowplot )
library ( ggforce )
library ( ggfortify )
library ( scales )
library ( reshape )
library ( proto )
library ( dplyr )
# devtools :: install _ github (" johannesbjork / LaCroixColoR ")
library ( LaCroixColoR )
devtools :: install _ github (" johannesbjork / LaCroixColoR ")
devtools::install_github("johannesbjork/LaCroixColoR")
installed.packages(packcircles)
library ( LaCroixColoR )
installed.packages('packcircles')
installed.packages('EnvStats')
### Load the necessary libraries
library(ggplot2)
library(Hmisc)
library(EnvStats)
library(plyr)
library(reshape2)
library(cowplot)
library(ggforce)
library(ggfortify)
library(scales)
library(reshape)
library(proto)
library(dplyr)
#devtools::install_github("johannesbjork/LaCroixColoR")
library(LaCroixColoR)
rmvn <- function(n, mu = 0, V = matrix(1)) {
# This function draws random samples from a multivariate
# normal distribution across a spatial grid, and is needed
# for creating our heterogeneous microbial "landscapes".
p <- length(mu)
if (any(is.na(match(dim(V), p))))
stop("Dimension problem!")
D <- chol(V)
t(matrix(rnorm(n * p), ncol = p) %*% D + rep(mu, rep(n, p)))
}
discrete<-function(Ns,rs,K,as){
##  A discrete-time Lotka-Volterra competition function
# Ns are the population abundances
# rs are the growth rates
# K is the local carrying capacity
# as are the competition coefficients
return(as.numeric(Ns*exp(rs*(1-((as%*%Ns)/K)))))
}
find_neighbour<-function(vec,dat=dat){
# A helper function returning line numbers of all
# neighbouring cells
lnb<-which(dat[,"x"]%in%(vec["x"]+c(-1,-1,-1,0,1,1,1,0)) & dat[,"y"]%in%(vec["y"]+c(-1,0,1,1,1,0,-1,-1)))
lnb<-lnb[which(lnb!=vec["lnb"])]
return(lnb)
}
# Return intergroup correlation coefficients between OTUs
corfunc <- function(xx) return(data.frame(COR = cor(xx$N1, xx$N2)))
set.seed(680318)
# Set up a square lattice region; should be a multiple of
# 12 to allow for 3 carrying capacities and 4 samples.
dat <- expand.grid(1:48, 1:48); names(dat) <- c("x", "y")
dat
# Set up a distance matrix
distance <- as.matrix(dist(dat))
ntot <- nrow(dat)
# Next, we assign parameters and other important values
generation <- 1:60 #number of generations
# seed landscape with randomized populations
dat$N1 <- 0.5+rnorm(ntot,0,0.1)
dat$N2 <- 0.5+rnorm(ntot,0,0.1)
dat$lnb <- 1:ntot # index value for each cell
as<-matrix(c(1,1.05,1.05,1),ncol=2,byrow=TRUE) # Competition parameters. a_jj are set to 1
rs<-c(1.5,1.5) # Growth rate for each OTU
ds<-c(0.05,0.05) # dispersal fraction to move between adjacent cells
neigh<-apply(dat,1,function(x) find_neighbour(x,dat)) # get list of neighbor cells
# Here, we generate the carrying capacities for each cell.
# To do so, we first chose an autocorrelation parameter, psi, which
# controls the degree of clustering or spatial autocorrelation in
# our samples. We set this to an intermediate value, but note that our results
# are quantitatively robust across a wide range of psi.
psi <- 0.15
qual <- rmvn(1, rep(0, ntot), exp(-psi * distance))
dat$qual <- as.numeric(cut2(qual, g=3))
dat$K <- ifelse(dat$qual == 1, dat$qual + rnorm(ntot, 0.01, 0.1), dat$qual + rnorm(ntot, 0.01, 0.25))
list_dat<-list(dat) # transform to list for updating during simulations
for(i in generation){
list_dat[[(i+1)]]<-rbind.fill(apply(list_dat[[i]],1,function(x){
# model population dynamics within one grid cell
intern<-(1-ds)*discrete(Ns=x[c("N1","N2")],rs=rs, K = x["K"], as=as)
# get information on neighboring cells
neigh_cell<-list_dat[[i]][neigh[[x["lnb"]]],]
# compute the number of immigrants from the 8 adjacent grid cells
imm<-(ds/8)*rowSums(apply(neigh_cell,1,function(y) discrete(Ns=y[c("N1","N2")],rs=rs,K = y["K"], as=as)))
# save the results to a data frame in our list
out<-data.frame(x=x["x"],y=x["y"],N1=intern[1]+imm[1],N2=intern[2]+imm[2],lnb=x["lnb"], qual =x["qual"], K =x["K"])
return(out)
}))
print(i)
}
exmpl<- list_dat[[60]]; exmpl$qual <- factor(exmpl$qual)
# Create 4 equally-sized samples from the landscape (can be done many ways besides this).
exmpl$samps <- ifelse(exmpl$x <= sqrt(ntot)/2 & exmpl$y > sqrt(ntot)/2, "A",
ifelse(exmpl$x > sqrt(ntot)/2 & exmpl$y > sqrt(ntot)/2, "B",
ifelse(exmpl$x > sqrt(ntot)/2 & exmpl$y <= sqrt(ntot)/2, "C",
"D")))
# Calculate the mean populations per sample for correlation
means <- aggregate(.~exmpl$samps, exmpl[c("N1", "N2")], FUN=mean); names(means) <- c("samps", "N1", "N2")
# Compute the correlation coefficeints
cor(means$N1, means$N2) # Sample correlation
mean(ddply(exmpl, .(qual), corfunc)$COR) # "True" mean correlation (averaged across K)
## Code for simulating spatial Lotka-Volterra models over different randomized landscapes.
reps <- 1000 # Set number of different randomizations
correl <- matrix(NA, ncol = 2, nrow = reps) # initialize matrix to store values
psis <- seq(0.0001,1,length = reps) # create vector of parameters for landscape generation
for(j in 1:reps){
set.seed(sample(1:1000000,1)) # random starting seed
generation <- 1:60
dat$N1 <- 0.5+rnorm(ntot,0,0.1); dat$N2 <- 0.5+rnorm(ntot,0,0.1); dat$lnb <- 1:ntot
neigh<-apply(dat,1,function(x) find_neighbour(x,dat))
psi <- psis[j]
qual <- rmvn(1, rep(0, ntot), exp(-psi * distance))
dat$qual <- as.numeric(cut2(qual, g=3))
dat$K <- dat$qual + rnorm(ntot, 0.01, 0.25)
list_dat<-list(dat)
# Run the model for a single landscape
for(i in generation){
list_dat[[(i+1)]]<-rbind.fill(apply(list_dat[[i]],1,function(x){
#population dynamics within one grid cell
intern<-(1-ds)*discrete(Ns=x[c("N1","N2")],rs=rs, K = x["K"], as=as)
#grab the neighbouring cells
neigh_cell<-list_dat[[i]][neigh[[x["lnb"]]],]
#the number of immigrant coming into the focal grid cell
imm<-(ds/8)*rowSums(apply(neigh_cell,1,function(y) discrete(Ns=y[c("N1","N2")],rs=rs,K = y["K"], as=as)))
out<-data.frame(x=x["x"],y=x["y"],N1=intern[1]+imm[1],N2=intern[2]+imm[2],lnb=x["lnb"], qual =x["qual"], K =x["K"])
return(out)
}))
}
#
exmpl<- list_dat[[60]]; exmpl$qual <- factor(exmpl$qual)
exmpl$samps <- ifelse(exmpl$x <= sqrt(ntot)/2 & exmpl$y <= sqrt(ntot)/2, "A",
ifelse(exmpl$x > sqrt(ntot)/2 & exmpl$y <= sqrt(ntot)/2, "B",
ifelse(exmpl$x <= sqrt(ntot)/2 & exmpl$y > sqrt(ntot)/2, "C",
"D")))
# Aggregate and compute sample and true means
means <- aggregate(.~exmpl$samps, exmpl[c("N1", "N2")], FUN=mean); names(means) <- c("samps", "N1", "N2")
correl[j,1] <- mean(ddply(exmpl, .(qual), corfunc)$COR) # "True" mean correlation averaged over K
correl[j,2] <- cor(means$N1, means$N2)  # Correlation of samples
print(j)
}
## Code for simulating spatial Lotka-Volterra models over different randomized landscapes.
reps <- 1 # Set number of different randomizations
correl <- matrix(NA, ncol = 2, nrow = reps) # initialize matrix to store values
psis <- seq(0.0001,1,length = reps) # create vector of parameters for landscape generation
for(j in 1:reps){
set.seed(sample(1:1000000,1)) # random starting seed
generation <- 1:60
dat$N1 <- 0.5+rnorm(ntot,0,0.1); dat$N2 <- 0.5+rnorm(ntot,0,0.1); dat$lnb <- 1:ntot
neigh<-apply(dat,1,function(x) find_neighbour(x,dat))
psi <- psis[j]
qual <- rmvn(1, rep(0, ntot), exp(-psi * distance))
dat$qual <- as.numeric(cut2(qual, g=3))
dat$K <- dat$qual + rnorm(ntot, 0.01, 0.25)
list_dat<-list(dat)
# Run the model for a single landscape
for(i in generation){
list_dat[[(i+1)]]<-rbind.fill(apply(list_dat[[i]],1,function(x){
#population dynamics within one grid cell
intern<-(1-ds)*discrete(Ns=x[c("N1","N2")],rs=rs, K = x["K"], as=as)
#grab the neighbouring cells
neigh_cell<-list_dat[[i]][neigh[[x["lnb"]]],]
#the number of immigrant coming into the focal grid cell
imm<-(ds/8)*rowSums(apply(neigh_cell,1,function(y) discrete(Ns=y[c("N1","N2")],rs=rs,K = y["K"], as=as)))
out<-data.frame(x=x["x"],y=x["y"],N1=intern[1]+imm[1],N2=intern[2]+imm[2],lnb=x["lnb"], qual =x["qual"], K =x["K"])
return(out)
}))
}
#
exmpl<- list_dat[[60]]; exmpl$qual <- factor(exmpl$qual)
exmpl$samps <- ifelse(exmpl$x <= sqrt(ntot)/2 & exmpl$y <= sqrt(ntot)/2, "A",
ifelse(exmpl$x > sqrt(ntot)/2 & exmpl$y <= sqrt(ntot)/2, "B",
ifelse(exmpl$x <= sqrt(ntot)/2 & exmpl$y > sqrt(ntot)/2, "C",
"D")))
# Aggregate and compute sample and true means
means <- aggregate(.~exmpl$samps, exmpl[c("N1", "N2")], FUN=mean); names(means) <- c("samps", "N1", "N2")
correl[j,1] <- mean(ddply(exmpl, .(qual), corfunc)$COR) # "True" mean correlation averaged over K
correl[j,2] <- cor(means$N1, means$N2)  # Correlation of samples
print(j)
}
correl_df <- data.frame(correl); names(correl_df) <- c("Local", "Aggregate")
correl_df
# Plot the results in a histogram
ggplot() + geom_histogram(data = correl_df, aes(x = Aggregate),
colour="gray", fill="gray", binwidth = 0.1) +
geom_vline(xintercept = mean(correl_df$Aggregate),lwd = 1, lty = "dashed") +
geom_vline(xintercept = mean(correl_df$Local), lwd = 1, lty = "dotted", col = "red") +
scale_y_continuous("Count", expand = c(0, 0)) +
scale_x_continuous("Pearson correlation coefficient", expand = c(0, 0), limits = c(-1.1,1.1))
correl_df <- data.frame(correl); names(correl_df) <- c("Local", "Aggregate")
correl_df
means
# Compute the correlation coefficeints
cor(means$N1, means$N2) # Sample correlation
mean(ddply(exmpl, .(qual), corfunc)$COR) # "True" mean correlation (averaged across K)
means
means$N1
means$N2
exmpl$
exmpl$x
exmpl$x
sqrt(ntot)
sqrt(ntot)/2
paste0(workdir,"/Result_master_dir/",parent_set_of_analyses)
### Read libraries
print(workdir)
workdir <- "/home/sean/Documents/testhmwfolder/SAMSARA"
#
parent_set_of_analyses <- 'Fig2'
#
#print(parent_set_of_analyses)
#workdir <- "/home/sean/Documents/testhmwfolder/SAMSARA"
#parent_set_of_analyses <- 'Fig2'
###########################################################################################
### Here we load all of the data analysis functions that are contained in scripts within the folder './Load_collectfunctions'
#setwd(workdir)
source(paste0(workdir,c('/simulation_code/Load_collect_functions/collectfuns.R')))
paste0(workdir,c('/simulation_code/Load_collect_functions/collectfuns.R'))
workdir <- "/home/sean/Documents/testhmwfolder/SAMSARA"
#
parent_set_of_analyses <- 'Fig2'
#
#print(parent_set_of_analyses)
#workdir <- "/home/sean/Documents/testhmwfolder/SAMSARA"
#parent_set_of_analyses <- 'Fig2'
###########################################################################################
### Here we load all of the data analysis functions that are contained in scripts within the folder './Load_collectfunctions'
setwd(workdir)
source(paste0(workdir,c('/simulation_code/Load_collect_functions/collectfuns.R')))
paste0(workdir,c('/simulation_code/Load_collect_functions/collectfuns.R'))
workdir <- "/home/sean/Documents/testhmwfolder/SAMSARA"
#
print(paste("Before setwd:", workdir))
setwd(workdir)
print(paste("After setwd:", workdir))
source(paste0(workdir,c('/simulation_code/Load_collect_functions/collectfuns.R')))
print(paste("After setwd:", workdir))
?sjPlot
