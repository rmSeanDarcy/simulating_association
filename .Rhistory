settings2 <- as.data.frame(cbind(c('sdim_vec','ncubes_vec','nperm2','p_val_thr2','noise_mode','noise_std','euc_thr_pos','euc_thr_neg','corcoeff_thr_neg','corcoeff_thr_pos'),
c(paste(round(sdim_vec,3), collapse = ' '),paste(ncubes_vec, collapse = ' '),nperm2,p_val_thr2,noise_mode,noise_std,euc_thr_pos,euc_thr_neg,corcoeff_thr_neg,corcoeff_thr_pos)))
colnames(settings2) <- colnames(settings)
settings <- rbind(settings,settings2)
write.csv(settings,'settings_updated.csv')
##############################################################################################################################
##### 3. Set additional parameters for analysis
##############################################################################################################################
### The following data frames will be filled with results from respective analyses
## Basic data
npop_cubd_log <- c()            # All species abundance tables analysed
kabs_cubd_log <- c()            # All resource abundance tables analysed
div_res_log <- c()              # Metrics on community data (richness, beta diversity etc.)
div_rsc_res_log <- c()          # Metrics on resource data (richness, beta diversity etc.)
sign_ajd_res_log <- c()         # Log file for all significant and thresholded species x species correlations -> Co-occurrence adjacency matrices
sp_correl_log <- c()            # -> All species x species correlations
sprsc_cor_res_log <- c()        # Log file for all significant and thresholded species x resource correlations
sprsc_correl_log <- c()         # -> All species x resource correlations
## Co-occurrence data
infmat_res_log <- c()           # Big log file with all species pairwise combinations and relevant metrics
# -> co-occurrence, interaction coefficients, environmental preference similarity, environmental triplets, ...
infmat_num_res_log <- c()       # Co-occurrences quantities -> Number of positive/negative co-occurrences and positive/negative triplets
###########################################################################################
### Subsampling habitats and analysing data
hab_smpl_num <- ncubes_vec
### Cycle through the specified number of habitats of interest (in the paper only 25, apart from the testing where we analyse 10-300 in Supporting information)
#h <- hab_smpl_num[1]
for (h in hab_smpl_num) {
npopd <- c()
kabsd <- c()
nxyzd <- c()
for (r in r_num) {
### Here we select a random number of habitats, and subsample every dataset by their indices
smpl_idx <- sample(nrow(npop[npop$repl == r,]))[1:h]
npopr <- npop[npop$repl == r,]
npopd <- as.data.frame(rbind(npopd, npopr[smpl_idx,]))
kabsr <- kabs[kabs$repl == r,]
kabsd <- as.data.frame(rbind(kabsd, kabsr[smpl_idx,]))
nxyzr <- nxyz[nxyz$repl == r,]
nxyzd <- as.data.frame(rbind(nxyzd, nxyzr[smpl_idx,]))
}
###########################################################################################
### Main analysis functions
###########################################################################################
### The R scripts containing each function is added after the #
# All functions can be found within './Load_analysis_functions'
## Community and resource diversity metrics
div_res <- div_mtrcs(npopd, sp_num, hab_num = h, r_num, eucdm)          # diversity_functions.R
div_rsc_res <- div_mtrcs_rsc(kabsd, rsc_num, hab_num = h, r_num)        # diversity_functions.R
## Simple adjacency matrices (Spearmans correlations)
sp_correl <- get_signif_adj_all(npop, sp_num, r_num)                                            # calculate_coocurrence_functions.R
## Calculation of significant associations
sign_ajd_res <- get_signif_adj(npopd, p_val_thr2, nperm2, sp_num, r_num)                        # calculate_coocurrence_functions.R
sprsc_cor_res <- get_signif_sprsc(npopd, kabsd, p_val_thr2, nperm2, sp_num, rsc_num, r_num)     # calculate_coocurrence_functions.R
## Delete associations below defined thresholds (0.7 and -0.7 in paper)
sign_ajd_res[,1:(ncol(sign_ajd_res)-1)][sign_ajd_res[,1:(ncol(sign_ajd_res)-1)] < corcoeff_thr_pos & sign_ajd_res[,1:(ncol(sign_ajd_res)-1)] > corcoeff_thr_neg] <- 0
sprsc_cor_res[,1:(ncol(sprsc_cor_res)-1)][sprsc_cor_res[,1:(ncol(sprsc_cor_res)-1)] < corcoeff_thr_pos & sprsc_cor_res[,1:(ncol(sprsc_cor_res)-1)] > corcoeff_thr_neg] <- 0
## Prediction metrics
infmat_res <- get_pred_stats(sp_correl, sign_ajd_res, sp_num, r_num, eucdm, intm, sprsc_cor_res, rsc_num, sp_nms, pred_shuf, euc_thr_neg, euc_thr_pos)  # collecting_coocurrence_functions.R
###########################################################################################
### Save result data
## Saving results into result logs (d is the identifier = 'HabSubsmpl_' + h the number of habitats subsampled)
d_nm <- paste0('HabSubsmpl_',h)
# Find definitions of datasets above
npop_cubd_log <- rbind(npop_cubd_log, cbind(npopd, d=d_nm))
kabs_cubd_log <- rbind(kabs_cubd_log, cbind(kabsd, d=d_nm))
div_res_log <- rbind(div_res_log, cbind(div_res, d=d_nm))
div_rsc_res_log <- rbind(div_rsc_res_log, cbind(div_rsc_res, d=d_nm))
sp_correl_log <- rbind(sp_correl_log, cbind(sp_correl, d=d_nm))
sign_ajd_res_log <- rbind(sign_ajd_res_log, cbind(sign_ajd_res, d=d_nm))
sprsc_cor_res_log <- rbind(sprsc_cor_res_log, cbind(sprsc_cor_res, d=d_nm))
infmat_res_log <- rbind(infmat_res_log, cbind(infmat_res, d=d_nm))
print(paste0("Analysis complete for subsampling number: ",h))
}
###########################################################################################
## Next we calculate the means of basic diversity metrics
# Functions can be found in './Load_analysis_functions/means_for_all_runs_functions.R'
full_res_subdir_comp <- get_means_of_all_results(div_res_log,div_rsc_res_log)
## First we quantify how well the co-occurrences match drivers accross all runs
# Functions can be found in './Load_analysis_functions/matching_coocurrence_functions.R'
infm <- infmat_res_log
resl <- c()
j <- unique(infm$d)[1]
infmj <- infm[infm$d == j,]
## Now we assess matches in each individual run
#r <- 0
res <- c()
for (r in unique(infm$repl)) {
infmr <- infmj[infmj$repl == r,]
###########################################################################################
### Get positive matching data
###########################################################################################
infmrp <- infmr[infmr$coocpos == 1,]
totp <- nrow(infmrp)
pd <- list(totp = totp,
eucp = (sum(infmrp$euc < euc_thr_pos))/totp,
intp = (sum(infmrp$intpos == 1))/totp,
shrp = (sum(infmrp$shrd_rsc_pos == 1))/totp,
eucshrp = (sum(infmrp$euc < euc_thr_pos & infmrp$shrd_rsc_pos == 1))/totp,
eucintp = (sum(infmrp$euc < euc_thr_pos & infmrp$intpos == 1))/totp,
shrintp = (sum(infmrp$shrd_rsc_pos == 1 & infmrp$intpos == 1))/totp,
eucshrintp = (sum(infmrp$euc < euc_thr_pos & infmrp$shrd_rsc_pos == 1 & infmrp$intpos == 1))/totp,
unxp = sum(infmrp$euc > euc_thr_pos & infmrp$intpos == 0 & infmrp$shrd_rsc_pos == 0)/totp)
# All comparisons considered
pd$eucp_cor <- pd$eucp - (pd$eucshrp - pd$eucshrintp) - (pd$eucintp - pd$eucshrintp) - pd$eucshrintp
pd$shrp_cor <- pd$shrp - (pd$eucshrp - pd$eucshrintp) - (pd$shrintp - pd$eucshrintp) - pd$eucshrintp
pd$intp_cor <- pd$intp - (pd$eucintp - pd$eucshrintp) - (pd$shrintp - pd$eucshrintp) - pd$eucshrintp
pd$eucshrp_cor <- pd$eucshrp - pd$eucshrintp
pd$eucintp_cor <- pd$eucintp - pd$eucshrintp
pd$shrintp_cor <- pd$shrintp - pd$eucshrintp
# A Resource preference and interactions based matching considered
pd$eucp_corA <- pd$eucp - pd$eucintp
pd$intp_corA <- pd$intp - pd$eucintp
pd$eucintp_corA <- pd$eucintp
pd$unxpA <- pd$unxp + (pd$shrp - (pd$eucshrp) - (pd$shrintp - pd$eucshrintp))
# B Resource preference and shared resource association based matching considered
pd$eucp_corB <- pd$eucp - pd$eucshrp
pd$shrp_corB <- pd$shrp - pd$eucshrp
pd$eucshrp_corB <- pd$eucshrp
pd$unxpB <- pd$unxp + (pd$intp - (pd$eucintp) - (pd$shrintp - pd$eucshrintp))
resp <- unlist(pd)
###########################################################################################
### Get negative matching data
###########################################################################################
infmrn <- infmr[infmr$coocneg == 1,]
totn <- nrow(infmrn)
pd <- list(totn = totn,
eucn = (sum(infmrn$euc > euc_thr_neg))/totn,
intn = (sum(infmrn$intneg == 1))/totn,
shrn = (sum(infmrn$shrd_rsc_neg == 1))/totn,
eucshrn = (sum(infmrn$euc > euc_thr_neg & infmrn$shrd_rsc_neg == 1))/totn,
eucintn = (sum(infmrn$euc > euc_thr_neg & infmrn$intneg == 1))/totn,
shrintn = (sum(infmrn$shrd_rsc_neg == 1 & infmrn$intneg == 1))/totn,
eucshrintn = (sum(infmrn$euc > euc_thr_neg & infmrn$shrd_rsc_neg == 1 & infmrn$intneg == 1))/totn,
unxn = sum(infmrn$euc < euc_thr_neg & infmrn$intneg == 0 & infmrn$shrd_rsc_neg == 0)/totn)
# All comparisons considered
pd$eucn_cor <- pd$eucn - (pd$eucshrn - pd$eucshrintn) - (pd$eucintn - pd$eucshrintn) - pd$eucshrintn
pd$shrn_cor <- pd$shrn - (pd$eucshrn - pd$eucshrintn) - (pd$shrintn - pd$eucshrintn) - pd$eucshrintn
pd$intn_cor <- pd$intn - (pd$eucintn - pd$eucshrintn) - (pd$shrintn - pd$eucshrintn) - pd$eucshrintn
pd$eucshrn_cor <- pd$eucshrn - pd$eucshrintn
pd$eucintn_cor <- pd$eucintn - pd$eucshrintn
pd$shrintn_cor <- pd$shrintn - pd$eucshrintn
# B Resource preference and shared resource association based matching considered
pd$eucn_corA <- pd$eucn - pd$eucintn
pd$intn_corA <- pd$intn - pd$eucintn
pd$eucintn_corA <- pd$eucintn
pd$unxnA <- pd$unxn + (pd$shrn - (pd$eucshrn) - (pd$shrintn - pd$eucshrintn))
#
pd$eucn_corB <- pd$eucn - pd$eucshrn
pd$shrn_corB <- pd$shrn - pd$eucshrn
pd$eucshrn_corB <- pd$eucshrn
pd$unxnB <- pd$unxn + (pd$intn - (pd$eucintn) - (pd$shrintn - pd$eucshrintn))
resn <- unlist(pd)
res <- rbind(res, c(resp,resn))
}
res
View(res)
resx <- c()
#k <- 1
# Get means for all runs -> Ignore Runs with NaN values (f.ex. where there were no negative co-occurrences)
for (k in 1:ncol(res)) {
resx <- c(resx, sum(res[!is.na(res[,k]),k])/length(res[!is.na(res[,k]),k]))
}
names(resx) <- colnames(res)
resx
# Number of runs with zeros
resx['nzerop'] <- sum(res[,'totp'] == 0)
resx['nzeron'] <- sum(res[,'totn'] == 0)
resx
resx['nzeron']
# Average number of co-occurrences including zeros
resx['cor_totp'] <- sum(res[res[,'totp'] > 0,][,'totp'])/sum(res[,'totp'] > 0)
resx['cor_totp']
# Average number of co-occurrences including zeros
resx['cor_totp'] <- sum(res[res[,'totp'] > 0,][,'totp'])/sum(res[,'totp'] > 0)
resx['cor_totn'] <- sum(res[res[,'totn'] > 0,][,'totn'])/sum(res[,'totn'] > 0)
resx['cor_totn']
resx
resl <- c()
## We cycle through each number of habitats sampled (d)
#j <- unique(infm$d)[1]
for (j in unique(infm$d)) {
infmj <- infm[infm$d == j,]
## Now we assess matches in each individual run
#r <- 0
res <- c()
for (r in unique(infm$repl)) {
infmr <- infmj[infmj$repl == r,]
###########################################################################################
### Get positive matching data
###########################################################################################
infmrp <- infmr[infmr$coocpos == 1,]
totp <- nrow(infmrp)
pd <- list(totp = totp,
eucp = (sum(infmrp$euc < euc_thr_pos))/totp,
intp = (sum(infmrp$intpos == 1))/totp,
shrp = (sum(infmrp$shrd_rsc_pos == 1))/totp,
eucshrp = (sum(infmrp$euc < euc_thr_pos & infmrp$shrd_rsc_pos == 1))/totp,
eucintp = (sum(infmrp$euc < euc_thr_pos & infmrp$intpos == 1))/totp,
shrintp = (sum(infmrp$shrd_rsc_pos == 1 & infmrp$intpos == 1))/totp,
eucshrintp = (sum(infmrp$euc < euc_thr_pos & infmrp$shrd_rsc_pos == 1 & infmrp$intpos == 1))/totp,
unxp = sum(infmrp$euc > euc_thr_pos & infmrp$intpos == 0 & infmrp$shrd_rsc_pos == 0)/totp)
# All comparisons considered
pd$eucp_cor <- pd$eucp - (pd$eucshrp - pd$eucshrintp) - (pd$eucintp - pd$eucshrintp) - pd$eucshrintp
pd$shrp_cor <- pd$shrp - (pd$eucshrp - pd$eucshrintp) - (pd$shrintp - pd$eucshrintp) - pd$eucshrintp
pd$intp_cor <- pd$intp - (pd$eucintp - pd$eucshrintp) - (pd$shrintp - pd$eucshrintp) - pd$eucshrintp
pd$eucshrp_cor <- pd$eucshrp - pd$eucshrintp
pd$eucintp_cor <- pd$eucintp - pd$eucshrintp
pd$shrintp_cor <- pd$shrintp - pd$eucshrintp
# A Resource preference and interactions based matching considered
pd$eucp_corA <- pd$eucp - pd$eucintp
pd$intp_corA <- pd$intp - pd$eucintp
pd$eucintp_corA <- pd$eucintp
pd$unxpA <- pd$unxp + (pd$shrp - (pd$eucshrp) - (pd$shrintp - pd$eucshrintp))
# B Resource preference and shared resource association based matching considered
pd$eucp_corB <- pd$eucp - pd$eucshrp
pd$shrp_corB <- pd$shrp - pd$eucshrp
pd$eucshrp_corB <- pd$eucshrp
pd$unxpB <- pd$unxp + (pd$intp - (pd$eucintp) - (pd$shrintp - pd$eucshrintp))
resp <- unlist(pd)
###########################################################################################
### Get negative matching data
###########################################################################################
infmrn <- infmr[infmr$coocneg == 1,]
totn <- nrow(infmrn)
pd <- list(totn = totn,
eucn = (sum(infmrn$euc > euc_thr_neg))/totn,
intn = (sum(infmrn$intneg == 1))/totn,
shrn = (sum(infmrn$shrd_rsc_neg == 1))/totn,
eucshrn = (sum(infmrn$euc > euc_thr_neg & infmrn$shrd_rsc_neg == 1))/totn,
eucintn = (sum(infmrn$euc > euc_thr_neg & infmrn$intneg == 1))/totn,
shrintn = (sum(infmrn$shrd_rsc_neg == 1 & infmrn$intneg == 1))/totn,
eucshrintn = (sum(infmrn$euc > euc_thr_neg & infmrn$shrd_rsc_neg == 1 & infmrn$intneg == 1))/totn,
unxn = sum(infmrn$euc < euc_thr_neg & infmrn$intneg == 0 & infmrn$shrd_rsc_neg == 0)/totn)
# All comparisons considered
pd$eucn_cor <- pd$eucn - (pd$eucshrn - pd$eucshrintn) - (pd$eucintn - pd$eucshrintn) - pd$eucshrintn
pd$shrn_cor <- pd$shrn - (pd$eucshrn - pd$eucshrintn) - (pd$shrintn - pd$eucshrintn) - pd$eucshrintn
pd$intn_cor <- pd$intn - (pd$eucintn - pd$eucshrintn) - (pd$shrintn - pd$eucshrintn) - pd$eucshrintn
pd$eucshrn_cor <- pd$eucshrn - pd$eucshrintn
pd$eucintn_cor <- pd$eucintn - pd$eucshrintn
pd$shrintn_cor <- pd$shrintn - pd$eucshrintn
# B Resource preference and shared resource association based matching considered
pd$eucn_corA <- pd$eucn - pd$eucintn
pd$intn_corA <- pd$intn - pd$eucintn
pd$eucintn_corA <- pd$eucintn
pd$unxnA <- pd$unxn + (pd$shrn - (pd$eucshrn) - (pd$shrintn - pd$eucshrintn))
#
pd$eucn_corB <- pd$eucn - pd$eucshrn
pd$shrn_corB <- pd$shrn - pd$eucshrn
pd$eucshrn_corB <- pd$eucshrn
pd$unxnB <- pd$unxn + (pd$intn - (pd$eucintn) - (pd$shrintn - pd$eucshrintn))
resn <- unlist(pd)
res <- rbind(res, c(resp,resn))
}
resx <- c()
resy <- c()
#k <- 1
# Get means for all runs -> Ignore Runs with NaN values (f.ex. where there were no negative co-occurrences)
for (k in 1:ncol(res)) {
resx <- c(resx, sum(res[!is.na(res[,k]),k])/length(res[!is.na(res[,k]),k]))
resy <- c(resx, sd(res[!is.na(res[,k]),k])/length(res[!is.na(res[,k]),k]))
}
names(resx) <- colnames(res)
names(resy) <- paste0(colnames(res),'_sd')
resx <- c(resx,resy)
###########################################################################################
### Correct for number of runs with zero co-occurrences -> Required for calculations later!
# Number of runs with zeros
resx['nzerop'] <- sum(res[,'totp'] == 0)
resx['nzeron'] <- sum(res[,'totn'] == 0)
# Average number of co-occurrences including zeros
resx['cor_totp'] <- sum(res[res[,'totp'] > 0,][,'totp'])/sum(res[,'totp'] > 0)
resx['cor_totn'] <- sum(res[res[,'totn'] > 0,][,'totn'])/sum(res[,'totn'] > 0)
resl <- rbind(resl, c(resx, d = j))
}
resl <- as.data.frame(resl)
resl
resx <- c()
resy <- c()
#k <- 1
# Get means for all runs -> Ignore Runs with NaN values (f.ex. where there were no negative co-occurrences)
for (k in 1:ncol(res)) {
resx <- c(resx, sum(res[!is.na(res[,k]),k])/length(res[!is.na(res[,k]),k]))
resy <- c(resx, sd(res[!is.na(res[,k]),k]))
}
resl <- c()
## We cycle through each number of habitats sampled (d)
#j <- unique(infm$d)[1]
for (j in unique(infm$d)) {
infmj <- infm[infm$d == j,]
## Now we assess matches in each individual run
#r <- 0
res <- c()
for (r in unique(infm$repl)) {
infmr <- infmj[infmj$repl == r,]
###########################################################################################
### Get positive matching data
###########################################################################################
infmrp <- infmr[infmr$coocpos == 1,]
totp <- nrow(infmrp)
pd <- list(totp = totp,
eucp = (sum(infmrp$euc < euc_thr_pos))/totp,
intp = (sum(infmrp$intpos == 1))/totp,
shrp = (sum(infmrp$shrd_rsc_pos == 1))/totp,
eucshrp = (sum(infmrp$euc < euc_thr_pos & infmrp$shrd_rsc_pos == 1))/totp,
eucintp = (sum(infmrp$euc < euc_thr_pos & infmrp$intpos == 1))/totp,
shrintp = (sum(infmrp$shrd_rsc_pos == 1 & infmrp$intpos == 1))/totp,
eucshrintp = (sum(infmrp$euc < euc_thr_pos & infmrp$shrd_rsc_pos == 1 & infmrp$intpos == 1))/totp,
unxp = sum(infmrp$euc > euc_thr_pos & infmrp$intpos == 0 & infmrp$shrd_rsc_pos == 0)/totp)
# All comparisons considered
pd$eucp_cor <- pd$eucp - (pd$eucshrp - pd$eucshrintp) - (pd$eucintp - pd$eucshrintp) - pd$eucshrintp
pd$shrp_cor <- pd$shrp - (pd$eucshrp - pd$eucshrintp) - (pd$shrintp - pd$eucshrintp) - pd$eucshrintp
pd$intp_cor <- pd$intp - (pd$eucintp - pd$eucshrintp) - (pd$shrintp - pd$eucshrintp) - pd$eucshrintp
pd$eucshrp_cor <- pd$eucshrp - pd$eucshrintp
pd$eucintp_cor <- pd$eucintp - pd$eucshrintp
pd$shrintp_cor <- pd$shrintp - pd$eucshrintp
# A Resource preference and interactions based matching considered
pd$eucp_corA <- pd$eucp - pd$eucintp
pd$intp_corA <- pd$intp - pd$eucintp
pd$eucintp_corA <- pd$eucintp
pd$unxpA <- pd$unxp + (pd$shrp - (pd$eucshrp) - (pd$shrintp - pd$eucshrintp))
# B Resource preference and shared resource association based matching considered
pd$eucp_corB <- pd$eucp - pd$eucshrp
pd$shrp_corB <- pd$shrp - pd$eucshrp
pd$eucshrp_corB <- pd$eucshrp
pd$unxpB <- pd$unxp + (pd$intp - (pd$eucintp) - (pd$shrintp - pd$eucshrintp))
resp <- unlist(pd)
###########################################################################################
### Get negative matching data
###########################################################################################
infmrn <- infmr[infmr$coocneg == 1,]
totn <- nrow(infmrn)
pd <- list(totn = totn,
eucn = (sum(infmrn$euc > euc_thr_neg))/totn,
intn = (sum(infmrn$intneg == 1))/totn,
shrn = (sum(infmrn$shrd_rsc_neg == 1))/totn,
eucshrn = (sum(infmrn$euc > euc_thr_neg & infmrn$shrd_rsc_neg == 1))/totn,
eucintn = (sum(infmrn$euc > euc_thr_neg & infmrn$intneg == 1))/totn,
shrintn = (sum(infmrn$shrd_rsc_neg == 1 & infmrn$intneg == 1))/totn,
eucshrintn = (sum(infmrn$euc > euc_thr_neg & infmrn$shrd_rsc_neg == 1 & infmrn$intneg == 1))/totn,
unxn = sum(infmrn$euc < euc_thr_neg & infmrn$intneg == 0 & infmrn$shrd_rsc_neg == 0)/totn)
# All comparisons considered
pd$eucn_cor <- pd$eucn - (pd$eucshrn - pd$eucshrintn) - (pd$eucintn - pd$eucshrintn) - pd$eucshrintn
pd$shrn_cor <- pd$shrn - (pd$eucshrn - pd$eucshrintn) - (pd$shrintn - pd$eucshrintn) - pd$eucshrintn
pd$intn_cor <- pd$intn - (pd$eucintn - pd$eucshrintn) - (pd$shrintn - pd$eucshrintn) - pd$eucshrintn
pd$eucshrn_cor <- pd$eucshrn - pd$eucshrintn
pd$eucintn_cor <- pd$eucintn - pd$eucshrintn
pd$shrintn_cor <- pd$shrintn - pd$eucshrintn
# B Resource preference and shared resource association based matching considered
pd$eucn_corA <- pd$eucn - pd$eucintn
pd$intn_corA <- pd$intn - pd$eucintn
pd$eucintn_corA <- pd$eucintn
pd$unxnA <- pd$unxn + (pd$shrn - (pd$eucshrn) - (pd$shrintn - pd$eucshrintn))
#
pd$eucn_corB <- pd$eucn - pd$eucshrn
pd$shrn_corB <- pd$shrn - pd$eucshrn
pd$eucshrn_corB <- pd$eucshrn
pd$unxnB <- pd$unxn + (pd$intn - (pd$eucintn) - (pd$shrintn - pd$eucshrintn))
resn <- unlist(pd)
res <- rbind(res, c(resp,resn))
}
resx <- c()
resy <- c()
#k <- 1
# Get means for all runs -> Ignore Runs with NaN values (f.ex. where there were no negative co-occurrences)
for (k in 1:ncol(res)) {
resx <- c(resx, sum(res[!is.na(res[,k]),k])/length(res[!is.na(res[,k]),k]))
resy <- c(resx, sd(res[!is.na(res[,k]),k]))
}
names(resx) <- colnames(res)
names(resy) <- paste0(colnames(res),'_sd')
resx <- c(resx,resy)
###########################################################################################
### Correct for number of runs with zero co-occurrences -> Required for calculations later!
# Number of runs with zeros
resx['nzerop'] <- sum(res[,'totp'] == 0)
resx['nzeron'] <- sum(res[,'totn'] == 0)
# Average number of co-occurrences including zeros
resx['cor_totp'] <- sum(res[res[,'totp'] > 0,][,'totp'])/sum(res[,'totp'] > 0)
resx['cor_totn'] <- sum(res[res[,'totn'] > 0,][,'totn'])/sum(res[,'totn'] > 0)
resl <- rbind(resl, c(resx, d = j))
}
resl <- as.data.frame(resl)
resl
resx <- c()
resy <- c()
#k <- 1
# Get means for all runs -> Ignore Runs with NaN values (f.ex. where there were no negative co-occurrences)
for (k in 1:ncol(res)) {
# Extract the column
col_vals <- res[, k]
# Remove NAs
valid_vals <- col_vals[!is.na(col_vals)]
# Compute mean
mean_val <- mean(valid_vals)
resx <- c(resx, mean_val)
# Compute standard deviation
sd_val <- sd(valid_vals)
resy <- c(resy, sd_val)
}
names(resx) <- colnames(res)
names(resy) <- paste0(colnames(res),'_sd')
resy
resx <- c(resx,resy)
resx
resl <- c()
## We cycle through each number of habitats sampled (d)
#j <- unique(infm$d)[1]
for (j in unique(infm$d)) {
infmj <- infm[infm$d == j,]
## Now we assess matches in each individual run
#r <- 0
res <- c()
for (r in unique(infm$repl)) {
infmr <- infmj[infmj$repl == r,]
###########################################################################################
### Get positive matching data
###########################################################################################
infmrp <- infmr[infmr$coocpos == 1,]
totp <- nrow(infmrp)
pd <- list(totp = totp,
eucp = (sum(infmrp$euc < euc_thr_pos))/totp,
intp = (sum(infmrp$intpos == 1))/totp,
shrp = (sum(infmrp$shrd_rsc_pos == 1))/totp,
eucshrp = (sum(infmrp$euc < euc_thr_pos & infmrp$shrd_rsc_pos == 1))/totp,
eucintp = (sum(infmrp$euc < euc_thr_pos & infmrp$intpos == 1))/totp,
shrintp = (sum(infmrp$shrd_rsc_pos == 1 & infmrp$intpos == 1))/totp,
eucshrintp = (sum(infmrp$euc < euc_thr_pos & infmrp$shrd_rsc_pos == 1 & infmrp$intpos == 1))/totp,
unxp = sum(infmrp$euc > euc_thr_pos & infmrp$intpos == 0 & infmrp$shrd_rsc_pos == 0)/totp)
# All comparisons considered
pd$eucp_cor <- pd$eucp - (pd$eucshrp - pd$eucshrintp) - (pd$eucintp - pd$eucshrintp) - pd$eucshrintp
pd$shrp_cor <- pd$shrp - (pd$eucshrp - pd$eucshrintp) - (pd$shrintp - pd$eucshrintp) - pd$eucshrintp
pd$intp_cor <- pd$intp - (pd$eucintp - pd$eucshrintp) - (pd$shrintp - pd$eucshrintp) - pd$eucshrintp
pd$eucshrp_cor <- pd$eucshrp - pd$eucshrintp
pd$eucintp_cor <- pd$eucintp - pd$eucshrintp
pd$shrintp_cor <- pd$shrintp - pd$eucshrintp
# A Resource preference and interactions based matching considered
pd$eucp_corA <- pd$eucp - pd$eucintp
pd$intp_corA <- pd$intp - pd$eucintp
pd$eucintp_corA <- pd$eucintp
pd$unxpA <- pd$unxp + (pd$shrp - (pd$eucshrp) - (pd$shrintp - pd$eucshrintp))
# B Resource preference and shared resource association based matching considered
pd$eucp_corB <- pd$eucp - pd$eucshrp
pd$shrp_corB <- pd$shrp - pd$eucshrp
pd$eucshrp_corB <- pd$eucshrp
pd$unxpB <- pd$unxp + (pd$intp - (pd$eucintp) - (pd$shrintp - pd$eucshrintp))
resp <- unlist(pd)
###########################################################################################
### Get negative matching data
###########################################################################################
infmrn <- infmr[infmr$coocneg == 1,]
totn <- nrow(infmrn)
pd <- list(totn = totn,
eucn = (sum(infmrn$euc > euc_thr_neg))/totn,
intn = (sum(infmrn$intneg == 1))/totn,
shrn = (sum(infmrn$shrd_rsc_neg == 1))/totn,
eucshrn = (sum(infmrn$euc > euc_thr_neg & infmrn$shrd_rsc_neg == 1))/totn,
eucintn = (sum(infmrn$euc > euc_thr_neg & infmrn$intneg == 1))/totn,
shrintn = (sum(infmrn$shrd_rsc_neg == 1 & infmrn$intneg == 1))/totn,
eucshrintn = (sum(infmrn$euc > euc_thr_neg & infmrn$shrd_rsc_neg == 1 & infmrn$intneg == 1))/totn,
unxn = sum(infmrn$euc < euc_thr_neg & infmrn$intneg == 0 & infmrn$shrd_rsc_neg == 0)/totn)
# All comparisons considered
pd$eucn_cor <- pd$eucn - (pd$eucshrn - pd$eucshrintn) - (pd$eucintn - pd$eucshrintn) - pd$eucshrintn
pd$shrn_cor <- pd$shrn - (pd$eucshrn - pd$eucshrintn) - (pd$shrintn - pd$eucshrintn) - pd$eucshrintn
pd$intn_cor <- pd$intn - (pd$eucintn - pd$eucshrintn) - (pd$shrintn - pd$eucshrintn) - pd$eucshrintn
pd$eucshrn_cor <- pd$eucshrn - pd$eucshrintn
pd$eucintn_cor <- pd$eucintn - pd$eucshrintn
pd$shrintn_cor <- pd$shrintn - pd$eucshrintn
# B Resource preference and shared resource association based matching considered
pd$eucn_corA <- pd$eucn - pd$eucintn
pd$intn_corA <- pd$intn - pd$eucintn
pd$eucintn_corA <- pd$eucintn
pd$unxnA <- pd$unxn + (pd$shrn - (pd$eucshrn) - (pd$shrintn - pd$eucshrintn))
#
pd$eucn_corB <- pd$eucn - pd$eucshrn
pd$shrn_corB <- pd$shrn - pd$eucshrn
pd$eucshrn_corB <- pd$eucshrn
pd$unxnB <- pd$unxn + (pd$intn - (pd$eucintn) - (pd$shrintn - pd$eucshrintn))
resn <- unlist(pd)
res <- rbind(res, c(resp,resn))
}
resx <- c()
resy <- c()
#k <- 1
# Get means for all runs -> Ignore Runs with NaN values (f.ex. where there were no negative co-occurrences)
for (k in 1:ncol(res)) {
# Extract the column
col_vals <- res[, k]
# Remove NAs
valid_vals <- col_vals[!is.na(col_vals)]
# Compute mean
mean_val <- mean(valid_vals)
resx <- c(resx, mean_val)
# Compute standard deviation
sd_val <- sd(valid_vals)
resy <- c(resy, sd_val)
}
names(resx) <- colnames(res)
names(resy) <- paste0(colnames(res),'_sd')
resx <- c(resx,resy)
###########################################################################################
### Correct for number of runs with zero co-occurrences -> Required for calculations later!
# Number of runs with zeros
resx['nzerop'] <- sum(res[,'totp'] == 0)
resx['nzeron'] <- sum(res[,'totn'] == 0)
# Average number of co-occurrences including zeros
resx['cor_totp'] <- sum(res[res[,'totp'] > 0,][,'totp'])/sum(res[,'totp'] > 0)
resx['cor_totn'] <- sum(res[res[,'totn'] > 0,][,'totn'])/sum(res[,'totn'] > 0)
resl <- rbind(resl, c(resx, d = j))
}
resl <- as.data.frame(resl)
resl
